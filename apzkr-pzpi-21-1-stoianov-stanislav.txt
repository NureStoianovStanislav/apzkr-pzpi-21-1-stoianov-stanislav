Міністерство освіти і науки України
Харківський національний університет радіоелектроніки

Факультет комп’ютерних наук

Кафедра програмної інженерії

КУРСОВА РОБОТА
ПОЯСНЮВАЛЬНА ЗАПИСКА 
з навчальної дисципліни «Архітектура програмного забезпечення» 
Тема роботи: Програмна система для автоматизації бібліотек


Студент гр. ПЗПІ-21-1	_______________ Стоянов С.Ю.
							(підпис)
Керівник роботи	_______________ доц. Лещинський В.О.
							(підпис)

	Робота захищено «_» _____2024р. 
	з оцінкою ____________________
 
Комісія: 	_______________ доц. Лещинський В.О.
							(підпис)													_______________ доц. Лещинська І.О.
							(підпис)
	_______________ ст. викл. Сокорчук І.П.
							(підпис)


Харків
2024 р.
Харківський національний університет радіоелектроніки

Факультет  комп’ютерних наук		 Кафедра  програмної інженерії		
Спеціальність  121 – Інженерія програмного забезпечення					
Курс 		3             Семестр 					6					
Навчальна дисципліна  Архітектура програмного забезпечення				

ЗАВДАННЯ 
НА КУРСОВУ РОБОТУ СТУДЕНТОВІ
 
Стоянову Станіславу Юрійовичу

1. Тема роботи: Програмна система для автоматизації    
  бібліотек                                                                                                                           _
2. Термін узгодження завдання курсової роботи: «25» березня 2024 р.
3. Термін здачі студентом закінченої роботи: «10» червня 2024 р.
4. Вихідні дані до проекту (роботи): В програмній системі передбачити:
унікальність,  актуальність, розповсюдженість, масштабованість, локалізація, адміністрування системи, реалізація трьох компонентів (Back-end, Front-end, IoT)	
5. Зміст пояснювальної записки (перелік питань, що належить розробити)
вступ, аналіз предметної області, постановка задачі, проєктування бази даних,архітектура програмної системи, опис програмної системи, висновки, перелік джерел посилання, додатки								
6. Перелік графічного матеріалу (з точним зазначенням обов’язкових креслень), ER-діаграма бази даних, логічна схема бази даних, діаграма прецедентів, діаграма розгортання, діаграма пакетів, діаграма взаємодії, діаграма діяльності,  діаграма компонентів												
 
КАЛЕНДАРНИЙ ПЛАН


№	Назва етапів курсової роботи	Термін виконання етапів роботи	Примітки
1	Функціональна специфікація програмного проєкту	31.03.24	
2	Проєктування програмного проєкту	30.04.24	
3	Кодування програмного проєкту	20.05.24	
4	Оформлення пояснювальної записки	31.05.24	
5	Захист курсової роботи	10.06.24	

	Дата видачі завдання: «25» березня 2024 р.

	Керівник				  _______________     доц. Лещинський В.О.
							(підпис)


	Завдання прийняв до виконання
	ст. гр. ПЗПІ-21-1				________________     Стоянов С. Ю.
								(підпис)

 
РЕФЕРАТ


Пояснювальна записка до курсової роботи: 59 с., 22 рис., 2 табл., 4 додатки, 5 джерел.
АДМІНІСТРАТОР, БІБЛІОТЕКА, ЗАПОЗИЧЕННЯ КНИЖОК, КЛІЄНТ, КНИГА, ПОВЕРНЕННЯ, ПРОГРАМНА СИСТЕМА.

Об’єктом дослідження є сфера комерційних бібліотек та актуальне на сьогоднішній день питання запозичення літератури різних жанрів з метою розваги або отримання знань.
Метою курсової роботи є розробка системи, що дозволяє налаштовувати режим роботи бібліотек, забезпечує клієнтів можливістю швидко та зручно позичати та повертати книги в бібліотеку без участі працівників бібліотеки, передбачає отримання статистичних даних власниками бібліотек для подальшого використання при адмініструванні та ставить в пріоритет безпеку персональних даних користувачів системи.
Розробка програмної системи базується на використанні таких технологій як: мова програмування Rust та асинхронний час виконання Tokio, система управління базами даних PostgreSQL, веб-застосунок використовує мову програмування JavaScript та технологію React.js, програмний застосунок для смарт-пристрою розроблено за допомогою мови програмування Rust.
У результаті роботи здійснено програмну реалізацію системи для автоматизації роботи бібліотек. Програмна система складається з серверного застосунку, веб-застосунку та застосунку для смарт-пристрою.
 
ЗМІСТ


Вступ	7
1 Аналіз предметної області	9
    1.1 Бізнес-вимоги	9
        1.1.1 Бізнес-можливості	9
        1.1.2 Бізнес-цілі та критерії успіху	10
        1.1.3 Потреби клієнтів або ринку	10
        1.1.4 Бізнес-ризики	11
    1.2 Концепція рішення	11
        1.2.1 Окреслення концепції	11
        1.2.2 Головна функціональність	12
        1.2.3 Припущення та залежності	13
    1.3 Рамки та обмеження проєкту	13
        1.3.1 Рамки первинного випуску	13
        1.3.2 Рамки наступних випусків	16
        1.3.3 Обмеження та винятки	16
    1.4 Бізнес-контекст	17
        1.4.1 Профілі зацікавлених сторін	17
        1.4.2 Пріоритети проєкту	17
        1.4.3 Робоче середовище	18
2 Постановка задачі	20
3 Проєктування бази даних	21
    3.1 Побудова ER-діаграми	21
    3.2 Побудова логічної моделі бази даних на основі ER-діаграми	22
4 Архітектура програмної системи	25
    4.1 Архітектура серверної частини	25
    4.2 Архітектура IoT частини	29
    4.3 Архітектура клієнтської частини	34
5 Опис програмної системи	38
    5.1 Виклик і завантаження	38
    5.2 Призначення і логічна структура	39
    5.3 Опис програмної реалізації	40
Висновки	45
Перелік джерел посилання	46
Додаток А Програмний код серверної частини	47
Додаток Б Програмний код IoT пристрою	52
Додаток В Програмний код клієнтської частини	57
 
ВСТУП


Хоча ми живемо в епоху інформаційних технологій, де Інтернет надає доступ до безлічі даних, традиційні бібліотеки залишаються актуальними. Їх унікальна та спеціалізована інформація, яка не завжди доступна в мережі, разом із соціальними та культурними функціями, визначає їх важливість у сучасному суспільстві. Бібліотеки не лише зберігають книги та рукописи, але й слугують центрами спільноти, де люди можуть брати участь у культурних подіях, обговореннях та семінарах.
Однак управління бібліотеками, що переважно виконується вручну, включає в себе численні рутинні завдання, такі як каталогізація матеріалів та контроль за відвідуванням. Це призводить до незручностей як для персоналу, так і для відвідувачів. Наприклад, процес видачі та повернення книг може займати багато часу, а також інформація про наявність матеріалів не завжди легко доступна. Відсутність автоматизованих систем може спричинити черги та затримки, що негативно впливає на ефективність роботи бібліотеки та задоволеність користувачів.
Вирішення цих проблем може бути досягнуте за допомогою програмного забезпечення для управління бібліотекою. Автоматизація рутинних процесів та поліпшення обслуговування завдяки програмним рішенням дозволять зробити роботу бібліотек більш ефективною та зекономити час як для персоналу, так і для відвідувачів. Сучасні програмні рішення можуть включати системи автоматичного обліку книг, інформування про наявність матеріалів у реальному часі, а також онлайн-сервіси для бронювання та продовження терміну користування.
Більше того, автоматизовані системи управління бібліотеками можуть включати функції аналізу даних, що дозволяє працівникам бібліотек краще розуміти потреби відвідувачів та відповідно адаптувати свої колекції. Це може сприяти підвищенню рівня задоволеності користувачів та залученню нових відвідувачів. Крім того, автоматизація дозволяє знижувати кількість помилок, пов’язаних з людським фактором, що робить роботу бібліотеки більш надійною.
Важливим аспектом є також інтеграція бібліотечних систем з іншими інформаційними ресурсами та базами даних, що розширює можливості доступу до знань. Наприклад, спільні каталоги кількох бібліотек дозволяють користувачам швидко знайти необхідні матеріали, навіть якщо вони знаходяться в іншому закладі. Така кооперація робить бібліотеки ще більш цінними інформаційними центрами.
Автоматизація бібліотек також сприяє розвитку електронних книг та цифрових архівів, що відповідає сучасним тенденціям у використанні інформації. Електронні ресурси можуть бути доступні користувачам цілодобово, що значно підвищує зручність та гнучкість доступу до знань.
Отже, впровадження програмного забезпечення для управління бібліотеками є необхідним кроком у розвитку цих закладів в умовах інформаційного суспільства. Автоматизація не лише підвищує ефективність роботи бібліотек, але й забезпечує кращий сервіс для користувачів, робить бібліотеки більш інтегрованими в інформаційне середовище та відповідає сучасним потребам суспільства.
 
1 АНАЛІЗ ПРЕДМЕТНОЇ ОБЛАСТІ
1.1 Бізнес-вимоги
1.1.1 Бізнес-можливості


На сьогоднішній день існує ряд програмних продуктів, спрямованих на вирішення проблем управління бібліотекою.
Libero – це хмарне рішення для управління бібліотекою, яке відзначається простим інтерфейсом та гнучкістю налаштувань під різні типи бібліотек. Його мобільна версія, Libero GO, пропонує спрощений процес видачі та повернення матеріалів, але все ж потребує втручання працівника бібліотеки. Однак система не надає можливості відслідковувати заборгованості відвідувачів або надавати інформацію про наявні матеріали в бібліотеці.
Infiniti Management – цей пакет програмного забезпечення спрямований на управління бібліотекою в шкільних установах. Він надає інтуїтивно зрозумілий пошук матеріалів та сповіщення про заборгованості по електронній пошті. Однак через специфіку шкільних бібліотек, система має обмежену масштабованість і погано підходить для інших типів бібліотек.
CodeAchi – це одна з найпопулярніших систем управління бібліотекою. Вона відома своєю персоналізацією, яка дозволяє користувачам налаштовувати процес каталогізації. Система також має потужну пошукову систему та автоматичні електронні повідомлення про прострочення. Проте відсутній мобільний застосунок для зручного доступу.
Запропонована система орієнтована на малі та середні бібліотеки в Європі, з можливістю розширення на глобальний ринок. Модель монетизації передбачає щомісячну підписку, яка покриватиме витрати на обслуговування, підтримку та оновлення програмного забезпечення.
 
1.1.2 Бізнес-цілі та критерії успіху


БЦ-1: Залучення нових клієнтів: Активним маркетингом та цільовою рекламою збільшити кількість бібліотек та відвідувачів, які скористаються новою програмною системою. 
БЦ-2: Збільшення прибутку: Залучити більше користувачів та забезпечити якісне обслуговування для збільшення прибутку. 
БЦ-3: Розширення ринку: Розширити ринок шляхом збільшення клієнтської бази та поліпшення функціоналу та обслуговування. 
КУ-1: Підвищення доходу: Збільшити прибуток на 15% протягом року користування програмним продуктом. 
КУ-2: Збільшення кількості користувачів: Впровадити програмну систему в щонайменше 10 бібліотеках протягом першого року на ринку. 
КУ-3: Вихід на більший ринок: Забезпечити присутність програмного продукту у 60% країн європейського регіону для розширення ринкової присутності.


1.1.3 Потреби клієнтів або ринку


Користувачі програмного продукту мають такі потреби: 
−	покращення ефективності: автоматизація рутинних завдань управління бібліотекою, таких як каталогізація матеріалів та звітність, щоб звільнити час персоналу бібліотек для інших завдань.
−	покращення якості обслуговування: більш зручний та швидкий доступ до інформації про наявність матеріалів у бібліотеці. Автоматизація процесу видачі та повернення матеріалів також є важливою.
−	зниження витрат: можливість заощадження коштів на персоналі завдяки автоматизації рутинних завдань та підвищенню ефективності роботи бібліотеки.


1.1.4 Бізнес-ризики


Одним з основних ризиків розробки даної системи є велика конкуренція на ринку управління бібліотеками, що може призвести до складнощів у здобутті частки на ринку. Цю проблему можна подолати шляхом інвестицій у маркетинг системи та постійного покращення якості обслуговування продукту для залучення більшої кількості користувачів. 
Інші ризики полягають у складності впровадження системи через непристосованість користувачів до подібних рішень. Цей ризик можна зменшити шляхом розробки інтуїтивно зрозумілого інтерфейсу та впровадження служби підтримки користувачів. 


1.2 Концепція рішення
1.2.1 Окреслення концепції


Запропонований програмний продукт має за мету оптимізувати рутинні процеси в бібліотеці шляхом автоматизації каталогізації бібліотечних матеріалів та обслуговування користувачів. Основні цілі продукту включають підвищення ефективності роботи бібліотекарів, спрощення процесів, які займають багато часу, та покращення якості обслуговування для відвідувачів бібліотеки.
Автоматизація роботи бібліотеки здійснюватиметься за допомогою єдиної бази даних, де зберігатиметься інформація про бібліотечні матеріали та відвідувачів. Ця база даних дозволить серверу відстежувати наявність книг у бібліотеці, терміни повернення книг відвідувачами та виконувати операції на основі цих даних, такі як оновлення електронного каталогу чи надсилання повідомлень про заборгованість відвідувачам.
Клієнтський інтерфейс, розроблений для взаємодії працівників бібліотеки з сервером та базою даних, буде зручним і функціональним. Він дозволить працівникам вести облік нових матеріалів та відвідувачів, вести звітність та звертатися до служби підтримки у разі потреби.
Отже, цей програмний продукт спрямований на значне полегшення роботи бібліотечного персоналу та поліпшення обслуговування для відвідувачів.
Система також включає в себе сканер штрих-кодів для автоматизації видачі та повернення книг. Якщо ці книги зареєстровані в базі даних як наявні, вони зараховуватимуться як видані в поточний день і буде враховано час для запозичення без боргу для клієнта..


1.2.2 Головна функціональність


ГФ-1: Додавання, редагування та видалення інформації щодо бібліотечних матеріалів.
ГФ-2: Реєстрація та видалення відвідувачів у системі.
ГФ-3: Перегляд інформації про матеріали та відвідувачів бібліотеки.
ГФ-4: Генерація та друк штрих-кодів для бібліотечного матеріалу.
ГФ-5: Ведення звітності бібліотеки.
ГФ-6: Перегляд електронного каталогу бібліотеки.
ГФ-7: Отримання персональних рекомендацій на основі виданих книг.
ГФ-8: Самостійна видача та повернення бібліотечного матеріалу.
ГФ-9: Надання технічної підтримки користувачам.


1.2.3 Припущення та залежності


П-1: Працівники бібліотеки освоять інтерфейс системи.
П-2: Працівники бібліотеки будуть вносити правильну інформацію про бібліотечні матеріали.
П-3: Система зможе без проблем зберігати великий обсяг інформації в базі даних та обробляти її.
З-1: Бібліотека повинна бути обладнана сканером штрих-кодів для автоматизації процесу видачі матеріалів.
З-2: Усі бібліотечні матеріали повинні бути позначені штрих-кодами для сканування.


1.3 Рамки та обмеження проєкту
1.3.1 Рамки первинного випуску


Серверна частина повинна включати: 
−	реєстрацію, аутентифікацію та авторизацію користувачів: реалізація системи користувачів та механізмів входу з підтримкою ролей та прав доступу;
−	створення, перегляд, редагування та видалення бібліотек зі списку активних та підтримуваних;
−	додавання, перегляд, видалення та оновлення даних про книжки у бібліотеці;
−	створення записів запозичень, визначення оптимального терміну для запозичення даної книги для клієнта;
−	повернення книжок до бібліотеки з врахуванням визначеного строку повернення книги;
−	визначення вартості для запозичення з врахуванням денної ставки бібліотеки та ставки для боргу в разі повернення книги пізніше зазначеного терміну;
−	захист від атак: використання сучасних методів захисту, такі як параметризовані запити SQL, валідація вхідних даних, санітизація даних та використання безпечних Cookie для запобігання атакам SQL-Injection, XSS та CSRF; 
−	шифрування даних: використання зашифрованого звʼязку між елементами системи за рахунок використання стандарту асиметричного шифрування SSL з реалізацією OpenSSL, використання сучасних алгоритмів хешування, таких як Argon2id та використання стандартів аутентифікованої комунікації, таких як Json Web Token;
−	механізми резервного копіювання та відновлення даних: наявність механізмів резервного копіювання, які надають можливість відновлювати стан системи після можливих аварійних ситуацій.
IoT частина повинна включати: 
−	зчитування ідентифікаційних даних користувача та книжок для подальшої обробки інших введених даних;
−	створення записів запозичень книг з розрахунком оптимального терміну повернення книги з врахуванням частоти запозичень книг;
−	запис повернень книг до бібліотеки та врахування вартості запозичення з використанням ставки бібліотеки та зазначеного терміну для повернення книги;
−	налаштування пристроїв під час їх безпосереднього використання;
−	захист конфіденційності даних: всі дані, які збираються та надсилаються до інших елементів програмної системи IoT пристроями, будуть зашифровані за допомогою доступних реалізацій SSL специфікації.
Front-end частина повинна включати: 
−	зручний для використання графічний веб інтерфейс для взаємодії з іншими елементами програмної системи;
−	інтерфейс для реєстрації та входу в обліковий запис користувача для подальшої авторизації при взаємодії із серверною частиною програмної системи;
−	панель для адміністрування даними у програмній системі, що включає в себе створення, редагування, перегляд та видалення даних про бібліотеки, книжки в них та записи запозичень;
−	інтерфейс для створення та збереження результатів резервного копіювання даних програмної системи;
−	локалізований та інтернаціоналізований інтерфейс: підтримка української та англійської мови, використання інтернаціональних кодових таблиць символів, локалізоване обчислення та формат дати та часу, підтримка локального та універсального часу, порядку сортування текстових значень, різного напряму введення тексту; 
−	захист від XSS атак: використання сучасних інструментів для відображення гіпертекстових документів з очисткою користувацьких даних для запобігання Cross Site Scripting атак;
−	використання безпечного з’єднання з серверною частиною програмної системи шляхом використання протоколу передачі гіпертекстових даних HTTPS;
−	валідація введених даних: використання механізмів валідації для перевірки введених користувачем даних перед їх відправленням на сервер, для уникнення подальшої валідації завідома невірних даних сервером.
 
1.3.2 Рамки наступних випусків


Серверна частина може включати: 
−	відгуки про сервіс: можливість користувачам залишати відгуки про роботу системи та про доступні в ній бібліотеки; 
−	введення звітності бібліотеки: можливість автоматично вести звітність за різними критеріями, такими як кількість нових матеріалів, кількість відвідувачів, кількість виданих книг і т. д. для подальшого другу звітів працівниками бібліотеки.
Front-end частина може включати: 
−	інтерфейс для залишення відгуків про роботу застосунку та бібліотек, зареєстрованих в програмній системі;
−	інтерфейс для створення та експорту звітності про роботу бібліотеки за різними критеріями. 


1.3.3 Обмеження та винятки


−	залежність від доступу до мережі Інтернет пристроями системи;
−	залежність від обробки фінансових транзакцій стороною бібліотек, оскільки система тільки враховує суму для запозичення;
−	залежність від працівників бібліотеки для повернення книги на її місце на полицях;
−	залежність від працівників бібліотеки для надання консультації щодо роботи зі смарт пристроями у бібліотеці;
−	обмеження в часі розсилки повідомлень користувачам про їх заборгованості, оскільки розсилка є щоденною.

1.4 Бізнес-контекст
1.4.1 Профілі зацікавлених сторін


Профілі зацікавлених сторін проекту наведені в таблиці 1.1.

Таблиця 1.1 – Профілі зацікавлених сторін проєкту
Зацікавлена сторона	Головна цінність	Ставлення	Головний інтерес	Обмеження
Керівники	Зростання бізнесу	Досягнення високої якості продукту	Вивести бізнес на новий для нього рівень, виграти увагу клієнтів у конкурентів
	Бюджет проєкту
Власники бібліотек	Зменшення витрат	Зниження витрат на працюючий персонал	Автоматизація частини процесів	Необхідно стежити за станом смарт пристроїв для їх коректної роботи

Відвідувачі бібліотек	Швидкість обслуговування	Очікують підвищення зручності користування	Спрощення процесу обслуговування	Необхідність мати обліковий запис

Співробітники бібліотек	Відсутність рутинної частини праці	Очікують спрощення обслуговування клієнтів	Автоматизація робочого процесу	Необхідність освоєння програмної системи



1.4.2 Пріоритети проєкту


Пріоритети проєкту наведені в таблиці 1.2.
Таблиця 1.2 – Пріоритети проєкту
Показник	Виконання (етапи)	Обмеження (граничні значення)	Ступінь свободи (допустимий діапазон)
План робіт	продукт має бути випущеним до 10.06.2024		можливе відхилення від графіку на 1-2 місяці
Функціональність			90% функціоналу має працювати на випуску 1.0
Якість			у випуску 1.0 повинні пройти 100% тестувань
Персонал		максимальний розмір команди – один розробник та адміністратор	
Ціна		100000 гривень	допустиме відхилення на 15%
	

1.4.3 Робоче середовище


Програмна система буде використовуватися користувачами з різних країн, тому надзвичайно важливо забезпечити безперебійний доступ. Це буде забезпечено за допомогою хмарних сервісів Fly.io. В робочому середовищі основні компоненти представлені наступним чином:
−	серверна частина буде розроблена з використанням мови програмування Rust [1], що забезпечить безпеку даних та низьке використання програмних ресурсів;
−	база даних: У ролі бази даних буде використано СУБД PostgreSQL [2]. Це гарантує надійне зберігання даних і швидкий доступ до них;
−	користувацький інтерфейс: Для створення клієнтської частини проекту буде використана мова програмування Javascript з використанням бібліотеки React [3];
−	пристрій IoT: Для реалізації IoT-частини продукту буде використано платформу Arduino з використанням мови програмування Rust у середовищі no_std, для можливості виконання програми без операційної системи;
−	забезпечення безпеки: Планується використання протоколу HTTPS для забезпечення шифрування даних під час їх передачі. Також передбачено впровадження сучасних методів аутентифікації та авторизації для захисту від несанкціонованого доступу;
−	доступність та надійність: Система буде розміщена на сервері Fly.io з можливістю створення резервних копій та аварійного відновлення. Застосунок буде доступний для користувачів цілодобово без перерв у роботі.
 
2 ПОСТАНОВКА ЗАДАЧІ


За результатами попереднього аналізу предметної області, задачею курсової роботи було поставлено створення програмної системи для автоматизації роботи бібліотек.
База даних повинна включати інформацію про: користувачів, бібліотеки, книги, запозичення.
Для клієнта має бути реалізований такий функціонал:
	реєстрація та вхід в систему;
	перегляд бібліотек та доступних в них книг;
	запозичення книги;
	повернення книги;
	редагування своїх контактних даних.
Для адміністратора системи має бути реалізований такий функціонал:
	реєстрація та вхід в систему;
	створення нових бібліотек;
	редагування даних про бібліотеки;
	видалення бібліотек з системи;
	перегляд бібліотек та книжок в них;
	Створення резервних копій стану системи.
Також програмна система повинна підтримувати локалізацію та інтернаціоналізацію, а саме, забезпечувати: підтримку різних кодових таблиць символів, обчислення та формат дати та часу, локальний та універсальний час, метричні одиниці вимірювання, різні напрями введення тексту тощо. 
3 ПРОЄКТУВАННЯ БАЗИ ДАНИХ
3.1 Побудова ER-діаграми


На підставі аналізу предметної області, було визначено основні сутності та зв’язки між ними. Їх було представлено у вигляді ER-діаграми (див. рис. 3.1).

 
Рисунок 3.1 – ER-діаграма бази даних

Сутність Користувачі – це сутність, яка містить інформацію про користувачів системи, і пов’язана зв’язком «один-до-багатьох» із сутностями Бібліотеки та Запозичення.
Сутність Бібліотеки – це сутність, що містить інформацію про бібліотеки, які є зареєстрованими у системі, і пов’язана зв’язком «один-до-багатьох» із сутністю Книжки та зв’язком «багато-до-одного» із сутністю Користувачі.
Сутність Книги – це сутність, що містить інформацію про екземпляри книг, що знаходяться у бібліотеках, і пов’язана зв’язком «один-до-багатьох» із сутністю Запозичення та зв’язком «багато-до-одного» із сутністю Бібліотеки.
Сутність Запозичення – це сутність, що містить інформацію про запозичення книжок клієнтами, і пов’язана зв’язком «багато-до-одного» із сутностями Користувачі та Книги.


3.2 Побудова логічної моделі бази даних на основі ER-діаграми


Отже, у логічній моделі бази даних будуть представлені такі сутності:
	користувачі (users);
	бібліотеки (libraries);
	книги (books);
	запозичення (lendings).
Створимо таблицю користувачів (users). Вона буде складатися з таких атрибутів: id (первинний ключ), name, email, password_hash, refresh_secret, role.
Перевіримо таблицю users на відповідність третій нормальній формі:
	усі атрибути атомарні: містять лише одне значення, а не множину;
	відсутність повторюваності даних;
	усі неключові атрибути залежать від первинного ключа.
Отже, таблиця задовольняє першій, другій і третій нормальній формі.
Створимо таблицю бібліотек (libraries). Вона буде складатися з таких атрибутів: id (первинний ключ), name, address, daily_rate, overdue_rate, currency, owner_id (зовнішній ключ для зв’язку з таблицею users).
Перевіримо таблицю libraries на відповідність третій нормальній формі:
	усі атрибути атомарні: містять лише одне значення, а не множину;
	відсутність повторюваності даних;
	усі неключові атрибути залежать від первинного ключа.
Отже, таблиця задовольняє першій, другій і третій нормальній формі.
Створимо таблицю книг (books). Вона буде складатися з таких атрибутів: id (первинний ключ), year, name, genre, author, library_id (зовнішній ключ для зв’язку з таблицею libraries).
Перевіримо таблицю books на відповідність третій нормальній формі:
	усі атрибути атомарні: містять лише одне значення, а не множину;
	відсутність повторюваності даних;
	усі неключові атрибути залежать від первинного ключа.
Отже, таблиця задовольняє першій, другій і третій нормальній формі.
Створимо таблицю запозичень (lendings). Вона буде складатися з таких атрибутів: id (первинний ключ), lent_on, due_date, returned_on, book_id (зовнішній ключ для зв’язку з таблицею books), lendee_id (зовнішній ключ для зв’язку з таблицею users).
Перевіримо таблицю lendings на відповідність третій нормальній формі:
	усі атрибути атомарні: містять лише одне значення, а не множину;
	відсутність повторюваності даних;
	усі неключові атрибути залежать від первинного ключа.
Отже, таблиця задовольняє першій, другій і третій нормальній формі.
За результатами проектування таблиць та зв’язків майбутньої бази даних, отримано її логічну схему (див. рис. 3.2).
 
 
Рисунок 3.2 – Логічна схема бази даних

Оскільки всі таблиці в наведеній логічній схемі бази даних знаходяться в третій нормальній формі, то можна зробити висновок, що отримана база даних знаходиться в третій нормальній формі. 
4 АРХІТЕКТУРА ПРОГРАМНОЇ СИСТЕМИ
4.1 Архітектура серверної частини


Розроблена система передбачає 3 види акторів: адміністратор системи, власник бібліотеки та клієнт бібліотеки. 
Основними потребами адміністратора системи є: 
	додавання нових бібліотек, вказуючи прямих клієнтів системи, тобто власників бібліотек;
	перегляд існуючих бібліотек для отримання актуальних даних щодо стану бібліотек та їх економічної політики, вказаної в системі;
	оновлення даних бібліотек в разі зміни адресу, імені тощо;
	видалення бібліотек зі списку активних бібліотек з інтеграцією програмної системи;
	доступ до функціоналу, передбаченого для клієнтів бібліотек.
Основними потребами власників бібліотек є: 
	перегляд даних про свої бібліотеки;
	оновлення даних бібліотек, що визначають вартість послуг для клієнтів;
	додавання книг у список доступних у бібліотеці;
	перегляд книг у бібліотеці та позичених книг;
	оновлення даних книжок, що знаходяться в їх бібліотеках;
	видалення книжок зі списку доступних;
	відмічання позичення клієнтами книжок;
	відмічання повернення книжок до бібліотеки та підрахунок вартості для сплати клієнтом;
	перегляд списку клієнтів, що наразі мають позичені книги та перегляд боржників, що не повернули книги до зазначеної дати.
Основними потребами клієнтів бібліотек є: 
	перегляд списку бібліотек для їх пошуку;
	перегляд доступних книг у бібліотеках;
	пошук книг та їх рекомендації.
Діаграма прецедентів (див. рис. 4.1) детально описує взаємодію кожного актора з програмною системою. Створення діаграми дозволило чітко визначити функціональні потреби при розробці системи.

 
Рисунок 4.1 – Діаграма прецедентів серверної частини програмної системи 
Для розробки серверної частини програмної системи було обрано мову програмування Rust та використано технології Tokio та Axum для створення веб серверу з можливістю оброблювати велику кількість запитів одночасно та асинхронно. В якості системи управління базами даних було обрано PostgreSQL, до якого з серверного застосунка здійснюється доступ за допомогою технології SQLx, яка надає зручний інтерфейс для обробки SQL запитів, використовуючи програмний інтерфейс обраної мови програмування.
Для візуалізації використаних технологій було розроблено діаграму розгортання (див. рис. 4.2).

 
Рисунок 4.2 – Діаграма розгортання серверної частини програмної системи

Для демонстрації та тестування API використовується OpenApi (Swagger), що дозволяє зручно тестувати та документувати API, покращуючи якість та зручність розробки. 
Для забезпечення безпеки даних та конфіденційності використовується захищений протокол HTTPS, що захищає дані під час їхньої передачі. 
Для автоматизації процесу мапування між об’єктами використано бібліотеку AutoMapper. Це дозволяє зменшити кількість одноманітного коду при роботі з об'єктами даних та спрощує розробку серверної частини. 
Для тестування серверного застосунку було використано HTTP клієнт Insomnia, що підтримує увесь функціонал поточних версій протоколу та дозволяє надсилати та зберігати запити через зручний інтерфейс. Також було використано захищену версію протоколу HTTPS, що забезпечує безпеку передачі даних.
Для захисту персональних даних клієнтів та захисту даних, що є важливими для збереження критичної для бізнесу інформації було використано технології Json Web Tokens для аутентифікації користувачів через непідробні токени, блочний шифр Advanced Encryption Standard для шифрування порядкових ідентифікаторів сутностей у базі даних, було використано бібліотеки secrecy та zeroize для видалення важливих даних з пам’яті без можливих оптимізацій при компіляції.
Розроблений серверний застосунок був побудованих з використанням концепцій Clean Architecture [4] та Domain Driven Design [5]. Застосунок складається з шарів презентації, бізнес логіки та доступу до сторонніх сервісів або використання програмного інтерфейсу бібліотек. Кожен з перерахованих шарів є залежністю для попередніх.
Архітектура застосунку було візуалізовано у діаграмі пакетів (див. рис. 4.3).

 
Рисунок 4.3 – Діаграма пакетів серверної частини програмної системи
Приклади частин коду серверного застосунка представлено у додатку А.
Таким чином, було визначено архітектуру серверної частини програмної системи та технології для її створення.


4.2 Архітектура IoT частини


IoT-пристрій розробленої системи відповідає за запозичення та повернення книг до бібліотеки. Пристрій передбачає своє налаштування працівниками бібліотеки та відповідає за обробку даних, повʼязану з врахуванням вартості запозичень та сроку для запозичення книг клієнтами.
Взаємодія пристрою з сервером представлена на діаграмі прецедентів (див. рис. 4.4). 

 
Рисунок 4.4 – Діаграма прецедентів IoT частини програмної системи 
При розробці системи було прийнято рішення використовувати архітектурну модель, яка поєднує монолітну та модульну архітектури, щоб досягти балансу між простотою та розширюваністю. Було створено статичну бібліотеку, здатну компілюватись навіть для середовищ без операційної системи. Статична бібліотека дозволяє використовувати логіку програми з різними програмними інтерфейсами.
Важливим аспектом при створенні програмного застосунку було використання мінімальної кількості пам'яті та бути здатним працювати лише зі стеком пам’яті, для підтримки роботи на будь-яких смарт пристроях. 
Результатом цих архітектурних рішень стала UML діаграма діяльності, яка ілюструє структуру та взаємодію різних компонентів системи (див. рис. 4.5). 

 
Рисунок 4.5 – UML діаграма діяльності пристрою 
Під час розробки вбудованої частини системи було використано інструменти мови програмування Rust.
Для надсилання HTTP запитів було використано бібліотеку reqwest. Для обробки помилок – anyhow. Для роботи з часом, враховуючи часові пояса було використано бібліотеку chrono. Для серіалізації даних перед відправкою на сервер використано serde.
Для демонстрації структури використання пакетів усередині системи було створено UML-діаграму пакетів (див. рис. 4.6). Ця діаграма ілюструє взаємозв'язки та інтерфейси між різними компонентами розробленого програмного продукту забезпечення, що сприяє зрозумінню його структури та організації.


 
Рисунок 4.6 – Діаграма пакетів IoT частини програмної системи

Під час розробки вбудованої частини системи було використано інструменти мови програмування Rust.
Для надсилання HTTP запитів було використано бібліотеку reqwest. Для обробки помилок – anyhow. Для роботи з часом, враховуючи часові пояса було використано бібліотеку chrono. Для серіалізації даних перед відправкою на сервер використано serde.
Для демонстрації структури використання пакетів усередині системи було створено UML-діаграму пакетів (див. додаток A.3). Ця діаграма ілюструє взаємозв'язки та інтерфейси між різними компонентами розробленого програмного продукту забезпечення, що сприяє зрозумінню його структури та організації.
Результатом роботи став програмний застосунок для вбудованих систем, що може бути запущений на широкому спектрі різних пристроїв.
Під час запуску застосунку, спершу відбувається ініціалізація налаштувань та перевірка їх значень. У конфігурації можна редагувати локацію сервера для обробки даних. Програма чекає вводу даних від користувача з запитом наступної команди. В залежності від обраної команди пристрій запитує користувача усі необхідні дані для подальшої їх обробки та надсилання на сервер.
При налаштуванні системи пристрій питає у користувача нову локацію сервера для ЇЇ подальшого збереження та використання.
При запозиченні книги пристрій потребує ідентифікатор користувача та ідентифікатор книги. Ідентифікатор користувача може буде отриманим через картку клієнта шляхом її сканування. Сканування штрих-коду книги з бібліотеки надає ідентифікатор книги. Пристрій визначає поточну дату та срок для запозичення за рахунок визначення рівня попиту на книгу.
При поверненні книги пристрій сканує ідентифікатор (штрих код) книги та використовує його для надсилання актуальних даних на серверну частину програмної системи. 
Для демонстрації складної структури проекту була розроблена UML діаграма взаємодії (див. рис. 4.7).
 
 
Рисунок 4.7 – Діаграма взаємодії IoT частини програмної системи

Зазначений смарт пристрій, з точки зору структури, є доволі простим HTTP клієнтом, котрий оброблює дані як з серверу, так і дані, які ввів користувач через інтерактивний інтерфейс пристрою.
Для перевірки правильності роботи системи було проведено тестування. Тестування виконувалося вручну, з використання програмних підходів. Тестування було виконано, збудувавши програму під операційну систему MacOS та архітектуру процесора aarch64. Для демонстрації роботи було розроблено консольну програму на мові програмування Rust. При тестуванні було використано дані про завчасно створені книги та акаунти користувачів. Було змодельовано повний робочий процес бібліотеки з налаштуваннями системи, запозиченням та поверненням книг.
Приклади коду IoT частини системи представлено у додатку Б. 
 
4.3 Архітектура клієнтської частини


Розроблений програмний продукт розрахований на один тип акторів – адміністратора системи, оскільки проєкт являє собою панель адміністрування у програмній системі.
Необхідними потребами адміністратора є: можливість перегляду бібліотек, можливість їх редагування, можливість видалення існуючих бібліотек, можливість зміни власників бібліотек, можливість додавання нових бібліотек, можливість перегляду списку користувачів, яким можна передати володіння бібліотекою, можливість створення резервних копій бази даних та можливість завантаження резервних копій баз даних. Діаграма прецедентів (див. рис. 4.8) детально описує взаємодію користувача з системою.
	Розроблений програмний продукт має підтримку інтернаціоналізації і надає візуальний інтерфейс англійською та українською мовами.

 
Рисунок 4.8 – Діаграма прецедентів клієнтської частини програмної системи 
Для створення клієнської частини програмної системи було обрано мову програмування JavaScript. Цю мову програмування у стандарті EcmaScript 6 можуть інтерпретувати усі сучасні веб браузери.
Також було обрано бібліотеку React для створення репрезентації інтерфейсу програми у текстовому форматі HTML з використання даних зі структур даних у JavaScript програмі.
Було використано бібліотеку TailwindCSS для застосування стилів до елементів інтерфейсу. 
Для можливості мати більше однієї сторінки на сайті використано ReactRouter, що надає засоби для створення динамічної навігації у браузері.
Статичні дані та бандлінг сторінок в один JavaScript файл було реалізовано за допомогою інструменту Vite.
Для реалізації інтернаціоналізації та виконання запитів на сервер програмної системи було використано програмний інтерфейс веб браузеру.
Для візуалізації програмних залежностей було розроблено діаграму пакетів (див. рис. 4.9).

 
Рисунок 4.9 – Діаграма пакетів клієнтської частини програмної системи 
При розробці програмного застосунку було використано компонентну архітектуру, що передбачає своє використання із сучасними фреймворками для створення візуальних інтерфейсів. Для візуалізації залежностей між компонентами застосунку було створено діаграму компонентів (див. рис. 4.10).

 
Рисунок 4.10 – Діаграма компонентів клієнтської частини програмної системи

Використання програмного застосунку починається з домашньої сторінки, на якій відображено список всіх активних бібліотек. З цієї сторінки користувач також може перейти на сторінку входу в обліковий запис, сторінку створення облікових записів, сторінку перегляду та редагування обраної бібліотеки та на сторінку створення резервних копій бази даних програмної системи. На усіх сторінках присутні посилання для переходу на інші сторінки та кнопки вибору мови інтерфейсу, англійської чи української.
Для доступу до сторінок редагування даних та створення резервних копій користувач має бути аутентифікованим та авторизованим як адміністратор системи. Після вводу своїх даних для входу в обліковий запис та відправлення запиту на сервер браузер обробляє відповідь та встановлює дані Cookie, котрі будуть надсилатися з подальшими запитами для аутентифікації користувача. В разі якщо користувач не є адміністратором буде відображене повідомлення про це та перенаправлено на сторінку для входу в обліковий запис.
Для кращого уявлення про взаємодію користувачів з клієнтською частиною системи було розроблено діаграму взаємодії (див. рис. 4.11). 

 
Рисунок 4.11 – Діаграма взаємодії клієнтської частини програмної системи

У процесі проєктування застосунку системи було визначено основні технології та архітектурні рішення для подальшої розробки. 
У додатку В наведено приклади коду клієнтської частини програмної системи. 
5 ОПИС ПРОГРАМНОЇ СИСТЕМИ
5.1 Виклик і завантаження


Для виклику програми необхідно завантажити архів, у якому вона розповсюджується, та розархівувати її. Оскільки у програмному продукті використовується з’єднання із СУБД PostgreSQL, необхідно запустити її сервер локально за допомогою інструменту docker compose у директорії «apzkr-pzpi-21-1-stoianov-stanislav/Task1-Server» або встановити сумісну версію з офіційного сайту.
Щоб забезпечити з’єднання застосунку з базою даних, потрібно відкрити файл «development.yaml», розташований у директорії «apzkr-pzpi-21-1-stoianov-stanislav/Task1-Server/config» за допомогою будь-якого текстового редактора та змінити налаштування програмного застосунку. Поточні налаштування застосунку зображено на рис. 5.1.

 
Рисунок 5.1 – Налаштування застосунку 
Для запуску серверної частини програмної системи необхідно мати встановлену версію інструментів мови програмування Rust, що є рівною чи вищою за «1.75.0». Це можна зробити на офіційному сайті мови програмування Rust або використати пакетний менеджер Nix та виконати команду «nix develop» у корні серверного проєкту, що встановить версію інструментів, з якою було проведено розробку та функціональне тестування застосунку. Далі необхідно виконати команду «ENVIRONMENT=development cargo run» для компіляції та запуску сервера.
Для запуску сервера файлів клієнтської частини системи необхідно мати встановленим NodeJS версії 18 чи вище. Встановити актуальну версію можна через офіційний сайт або з використанням Nix та командою «nix develop», аналогічно з серверною частиною, але в директорії клієнтського проєкту.
Для компіляції IoT частини та запуску демо застосунку також необхідно мати Rust версією «1.75.0» чи вище. Можна використати версію, встановлену після запуску серверної частини або аналогічно з офіційного сайту Rust чи за допомогою команди «nix develop» у корні проєкту IoT частини програмної системи.


5.2 Призначення і логічна структура


Функції, які може виконувати програма, можна розбити на наступні логічні модулі:
	обліковий запис користувача;
	адміністрування бібліотеками;
	адміністрування книгами бібліотеки;
	запозичення книг
	перегляд бібліотек;
	адміністрування системою.
 
Модуль «Обліковий запис користувача» містить у собі функції для створення нового облікового запису, входу в створенний обліковий запис, перегляд даних про свого користувача та редагування своїх контактних даних.
Модуль «Адміністрування бібліотеками» містить у собі функції для створення, редагування та видалення бібліотек у системі адміністратором.
Модуль «Адміністрування книгами бібліотеки» містить у собі функції для додавання, видалення та редагування інформації про екземпляри книг у бібліотеці. Ці функції доступні для користувачів, котрим належить бібліотека, над якою виконується дія.
Модуль «Запозичення книг» містить у собі функції для створення нових записів запозичення книг клієнтами бібліотеки та повернення їх. Функціонал доступен акаунтам власників бібліотек, у яких відбувається дія.
Модуль «Перегляд бібліотек» містить у собі функції для усіх типів акторів системи та включає у себе перегляд бібліотек та книг, доступних в них.
Модуль «» містить у собі функції для створення резервних копій стану системи. Функціонал доступен для користувачів, авторизованих як адміністратор системи.


5.3 Опис програмної реалізації


При відкритті клієнтського застосунка можна побачити головну сторінку (див. рис. 5.2). 
На сторінці зображені бібліотеки в програмній системі. З цієї сторінки можна перейти на сторінки входу в обліковий запис та реєстрації. Також при наявності прав адміністратора можна перейти на сторінки створення нової бібліотеки, редагування існуючої бібліотеки та створення резервних копій стану системи. В разі спроби навігації на сторінки адміністрування неавторизованим користувачем, його буде направлено на сторінку входу в обліковий запис. Також у верхньому правому куті сайту є кнопки для зміни мови інтерфейсу. Вибір мов включає в себе англійську та українську.

 
Рисунок 5.2 – Головна сторінка сайту

Сторінки реєстрації та входу в обліковий запис (див. рис. 5.3) мають поля для вводу адреси електронної пошти та пароль користувача.

 
Рисунок 5.3 – Сторінка входу в обліковий запис

При авторизації як адміністратор системи можна перейти на сторінку редагування бібліотеки (див. рис. 5.4) натисканням на карту бібліотеки на головній сторінці сайту. Адміністратор має можливість змінювати назву, адресу, денну ставку, ставку заборгованості, валюту операцій в бібліотеці та її власника. Вибір валют та власників відбувається через випадний список для зручності користувачів. Інші вхідні дані є текстовими.
 
Рисунок 5.4 – Сторінка редагування бібліотеки

Також адміністратор системи має доступ до сторінки створення нової бібліотеки (див. рис. 5.5). Поля для вводу даних є аналогічними зі сторінкою редагування бібліотеки.

 
Рисунок 5.5 – Сторінка створення нової бібліотеки

Адміністратору системи доступна сторінка створення резервних копій стану системи (див. рис. 5.6). На сторінці є кнопка для запиту актуальної резервної копії, поле для перегляду відповіді сервера та кнопка завантаження резервної копії стану програмної системи.

 
Рисунок 5.6 – Сторінка створення резервних копій

При натисканні кнопки для запиту актуальної резервної копії (див. рис. 5.7) користувач може побачити відповідь на запит та кнопка завантаження резервної копії стане активною.

 
Рисунок 5.7 – Відповідь на запит створення резервної копії

При натисканні кнопки для завантаження отриманої резервної копії (див. рис. 5.8), відповідний файл, отриманий у відповіді сервера, буде завантажено на пристрій користувача.
 
Рисунок 5.8 – Завантаження резервної копії

Таким чином, було описано можливості взаємодії користувача з розробленою програмною системою. 
ВИСНОВКИ


За результатами виконання роботи було розроблено програмну систему для автоматизації роботи бібліотек.
У процесі роботи було проаналізовано предметну область, спроектовано структуру бази даних, розроблено архітектуру серверної, IoT та клієнтської частин програмної системи та реалізовано її програмними засобами Tokio, Rust та React.js відповідно.
Розроблена програмна система дозволяє зручно адмініструвати доступними у бібліотеках книгами, надає швидкий доступ до інформації про бібліотеки та доступні книги в них і автоматизує процес видачі та повернення книг клієнтами бібліотеки.
Функціональне тестування програмної системи є доступним у відео форматі за посиланням https://youtu.be/1SDTmWgOdMk. Результат перевірки пояснювальної записки до курсової роботи надано у додатку Г.
 
ПЕРЕЛІК ДЖЕРЕЛ ПОСИЛАННЯ


1.	The Rust Programming Language official website. URL: https://www.rust lang.org/ (дата звернення 17.06.2024).
2.	PostgreSQL 16.3 Documentation. PostgreSQL Documentation. URL: https://www.postgresql.org/docs/16/index.html (дата звернення: 17.06.2024).
3.	React Reference Overview – React. URL: https://react.dev/reference/react (дата звернення: 17.06.2024).
4.	Clean Code: A Handbook of Agile Software Craftmanship. Robert C. Martin, 2008.
5.	Domain Modeling Made Functional: Tackle Software Complexity. Scott Wlaschin, 2018.
 
ДОДАТОК А
Програмний код серверної частини
A.1 Код обробника запиту для входу в обліковий запис


 1 #[tracing::instrument(skip(state))]
 2 pub async fn sign_in(
 3     credentials: Credentials,
 4     state: AppState,
 5 ) -> crate::Result<TokenPair> {
 6     let (user_data, hash) = get_user(&credentials.email, &state.database)
 7         .await?
 8         .map(|u| ((u.id, u.refresh_secret), u.password_hash))
 9         .unzip();
10     telemetry::instrument_blocking(move || {
11         verify_password(
12             &credentials.password,
13             hash.as_ref(),
14             (*state.hasher_config).clone(),
15         )
16     })
17     .await??;
18     let (id, refresh_secret) = user_data.unwrap();
19     let id = UserId::new(id, &state.id_cipher);
20     let access_token = create_access_token(id, &state.jwt_config)?;
21     let refresh_token =
22         create_refresh_token(refresh_secret, &state.jwt_config)?;
23     Ok(TokenPair {
24         access_token,
25         refresh_token,
26     })
27 }

A.2 Код пакету для роботи з паролями користувачів


  1 use core::fmt;
  2
  3 use anyhow::Context;
  4 use argon2::{
  5     password_hash::{
  6         rand_core::OsRng, PasswordHasher, PasswordVerifier, SaltString,
  7     },
  8     Algorithm, Argon2, Params, Version,
  9 };
 10 use secrecy::{ExposeSecret, Secret};
 11
 12 use crate::{config::HasherConfig, error::Error};
 13
 14 pub type UnvalidatedPassword = Secret<String>;
 15
 16 #[derive(Clone, sqlx::Type)]
 17 #[sqlx(transparent, no_pg_array)]
 18 pub struct PasswordHash(String);
 19
 20 #[derive(Debug, sqlx::Type)]
 21 #[sqlx(transparent, no_pg_array)]
 22 pub struct Password(UnvalidatedPassword);
 23
 24 impl Password {
 25     pub fn new(value: UnvalidatedPassword) -> crate::Result<Self> {
 26         validate_password(value.expose_secret())
 27             .map(|_| Self(value))
 28             .map_err(Error::Validation)
 29     }
 30 }
 31
 32 fn validate_password(password: &str) -> Result<(), &'static str> {
 33     match password {
 34         p if p.len() < 8 => Err("password must be at least 8 characters long"),
 35         p if !p.chars().any(char::is_lowercase) => {
 36             Err("password must contain at least one lowercase character")
 37         }
 38         p if !p.chars().any(char::is_uppercase) => {
 39             Err("password must contain at least one uppercase character")
 40         }
 41         p if !p.chars().any(char::is_numeric) => {
 42             Err("password must contain at least one number")
 43         }
 44         _ => Ok(()),
 45     }
 46 }
 47
 48 #[tracing::instrument(skip_all, err(Debug))]
 49 pub fn hash_password(
 50     password: &Password,
 51     config: HasherConfig,
 52 ) -> crate::Result<PasswordHash> {
 53     let hasher = hasher(config.key.expose_secret().as_bytes(), config.params)?;
 54     let password = password.0.expose_secret().as_bytes();
 55     hash_bytes(hasher, password)
 56 }
 57
 58 #[tracing::instrument(skip_all, err(Debug, level = "debug"))]
 59 pub fn verify_password(
 60     password: &UnvalidatedPassword,
 61     hash: Option<&PasswordHash>,
 62     config: HasherConfig,
 63 ) -> crate::Result<()> {
 64     let hasher = hasher(config.key.expose_secret().as_bytes(), config.params)?;
 65     let password = password.expose_secret().as_bytes();
 66     match hash {
 67         Some(hash) => {
 68             let hash = argon2::PasswordHash::new(&hash.0)
 69                 .context("parse password hash")?;
 70             hasher
 71                 .verify_password(password, &hash)
 72                 .map_err(|_| Error::InvalidCredentials)
 73         }
 74         None => {
 75             hash_bytes(hasher, password).ok();
 76             Err(Error::InvalidCredentials)
 77         }
 78     }
 79 }
 80
 81 fn hash_bytes(
 82     hasher: Argon2<'_>,
 83     password: &[u8],
 84 ) -> crate::Result<PasswordHash> {
 85     hasher
 86         .hash_password(password, &SaltString::generate(&mut OsRng))
 87         .map(|hash| PasswordHash(hash.to_string()))
 88         .context("hash password")
 89         .map_err(crate::Error::from)
 90 }
 91
 92 fn hasher(secret: &[u8], params: Params) -> crate::Result<Argon2<'_>> {
 93     Argon2::new_with_secret(
 94         secret,
 95         Algorithm::default(),
 96         Version::default(),
 97         params,
 98     )
 99     .context("instantiate hasher")
100     .map_err(crate::Error::from)
101 }
102
103 impl TryFrom<UnvalidatedPassword> for Password {
104     type Error = Error;
105
106     fn try_from(value: UnvalidatedPassword) -> Result<Self, Self::Error> {
107         Self::new(value)
108     }
109 }
110
111 impl fmt::Debug for PasswordHash {
112     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
113         f.write_str("PasswordHash(...)")
114     }
115 }
 
A.3 Код обробника для отримання активних позичень книг


  1 #[tracing::instrument(skip(state))]
  2 pub async fn active_lendings(
  3     owner_id: UserId,
  4     library_id: LibraryId,
  5     state: AppState,
  6 ) -> crate::Result<Vec<Lending>> {
  7     let db_owner_id = owner_id
  8         .sql_id(&state.id_cipher)
  9         .map_err(|_| Error::LoggedOff)
 10         .inspect_err(telemetry::debug)?;
 11     let db_library_id = library_id
 12         .sql_id(&state.id_cipher)
 13         .map_err(|_| Error::NotFound)
 14         .inspect_err(telemetry::debug)?;
 15     check_owns(db_owner_id, db_library_id, &state.database).await?;
 16     let db_lendings =
 17         get_active_lendings(db_library_id, &state.database).await?;
 18     let mut lendings = Vec::with_capacity(db_lendings.len());
 19     for lending in db_lendings {
 20         let id = LendingId::new(lending.id, &state.id_cipher);
 21         let book_id = BookId::new(lending.book_id, &state.id_cipher);
 22         let lendee_id = UserId::new(lending.lendee_id, &state.id_cipher);
 23         let book = view_book(library_id, book_id, state.clone()).await?;
 24         let lendee = get_user(lendee_id, state.clone()).await?;
 25         let lending = Lending {
 26             id,
 27             book,
 28             lendee,
 29             lent_on: lending.lent_on,
 30             due: lending.due,
 31         };
 32         lendings.push(lending);
 33     }
 34     Ok(lendings)
 35 }

A.4 Код пакету для обробки помилок програми


 1 use core::fmt;
 2
 3 use crate::id;
 4
 5 pub type Result<T> = std::result::Result<T, Error>;
 6
 7 #[derive(Debug, thiserror::Error)]
 8 pub enum Error {
 9     #[error("{0}")]
10     Validation(&'static str),
11     #[error("account already exists")]
12     AccountExists,
13     #[error("sign in to continue")]
14     LoggedOff,
15     #[error("wrong email or password")]
16     InvalidCredentials,
17     #[error("requested resource not found")]
18     NotFound,
19     #[error("no permission for the resourse")]
20     Unauthorized,
21     #[error("an unexpected error occurred")]
22     Internal(#[from] ErrorChain),
23 }
24
25 impl From<anyhow::Error> for Error {
26     fn from(error: anyhow::Error) -> Self {
27         ErrorChain::from(error).into()
28     }
29 }
30
31 impl From<sqlx::Error> for Error {
32     fn from(error: sqlx::Error) -> Self {
33         anyhow::Error::from(error).context("execute sql").into()
34     }
35 }
36
37 impl From<id::DecodeError> for Error {
38     fn from(value: id::DecodeError) -> Self {
39         anyhow::Error::from(value).context("parse id").into()
40     }
41 }
42
43 #[derive(thiserror::Error)]
44 #[error(transparent)]
45 pub struct ErrorChain(#[from] anyhow::Error);
46
47 impl fmt::Debug for ErrorChain {
48     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
49         write!(f, "{self}")?;
50         std::iter::successors(self.0.source(), |err| err.source())
51             .try_for_each(|err| write!(f, ": {err}"))
52     }
53 }
 
ДОДАТОК Б
Програмний код IoT пристрою
Б.1 Код основного файлу логічної частини застосунку для смарт пристрою


  1 use std::time::Duration;
  2
  3 use anyhow::{anyhow, Context as error_handling, Result};
  4 use api::thread_rng as get_day;
  5 use chrono::{Local, NaiveDate};
  6 use rand as api;
  7 use rand::Rng;
  8 use serde::Serialize;
  9
 10 static BASE_URL: &str = "BASE_URL";
 11
 12 const MIN_THRESHOLD: u64 = 5;
 13 const MAX_LEND: u64 = 14;
 14
 15 #[derive(Clone, Debug, Serialize)]
 16 #[serde(rename_all = "camelCase")]
 17 struct LendRequest<'a> {
 18     lendee_id: &'a str,
 19     book_id: &'a str,
 20     lent_on: NaiveDate,
 21     lent_for: u64,
 22 }
 23
 24 #[derive(Clone, Debug, Serialize)]
 25 #[serde(rename_all = "camelCase")]
 26 struct ReturnRequest<'a> {
 27     book_id: &'a str,
 28 }
 29
 30 pub async fn lend_book(lendee_id: &str, book_id: &str) -> Result<()> {
 31     let endpoint = endpoint("/lendings/new")?;
 32     let today = Local::now().date_naive();
 33     let lent_for = calculate_days_to_lend(book_id).await?;
 34     let req = LendRequest {
 35         lendee_id,
 36         book_id,
 37         lent_on: today,
 38         lent_for,
 39     };
 40     reqwest::Client::builder()
 41         .timeout(Duration::new(1, 0))
 42         .build()
 43         .unwrap()
 44         .post(&endpoint)
 45         .form(&req)
 46         .send()
 47         .await
 48         .context("send http request")?
 49         .error_for_status()
 50         .map(|_| ())
 51         .context("process request")
 52 }
 53
 54 pub async fn return_book(book_id: &str) -> Result<()> {
 55     let endpoint = endpoint("/lendings/return")?;
 56     let req = ReturnRequest { book_id };
 57     reqwest::Client::builder()
 58         .timeout(Duration::new(1, 0))
 59         .build()
 60         .unwrap()
 61         .post(&endpoint)
 62         .form(&req)
 63         .send()
 64         .await
 65         .context("send http request")?
 66         .error_for_status()
 67         .map(|_| ())
 68         .context("process request")
 69 }
 70
 71 async fn calculate_days_to_lend(book_id: &str) -> Result<u64> {
 72     let endpoint = endpoint(&format!("/books/{book_id}/lending-score"))?;
 73     let score = reqwest::Client::builder()
 74         .timeout(Default::default())
 75         .build()
 76         .unwrap()
 77         .get(&endpoint)
 78         .send()
 79         .await
 80         .context("send http request")
 81         .and_then(|res| {
 82             format!("{res:?}")
 83                 .as_str()
 84                 .parse::<u64>()
 85                 .context("parse lend score")
 86         })
 87         .unwrap_or(get_day().gen_range(0..31));
 88     let days = match score {
 89         s if s < MIN_THRESHOLD => MAX_LEND - s,
 90         s if s < MAX_LEND => MAX_LEND / s,
 91         s => (MAX_LEND + s) / MIN_THRESHOLD,
 92     };
 93     Ok(days)
 94 }
 95
 96 pub fn init_settings() -> anyhow::Result<()> {
 97     std::env::var(BASE_URL)
 98         .map(|url| println!("Initialized with URL: {url}"))
 99         .map_err(|_| anyhow!("base url is unset"))
100 }
101
102 pub fn set_base_url(url: &str) {
103     std::env::set_var(BASE_URL, url);
104 }
105
106 fn endpoint(path: &str) -> anyhow::Result<String> {
107     let base_url = std::env::var(BASE_URL)?;
108     Ok(format!("{base_url}{path}"))
109 }

Б.2 Код демонстраційного програмного застосунку


 1 use std::io::Write;
 2 use ligma as lib;
 3
 4 #[tokio::main]
 5 async fn main() -> anyhow::Result<()> {
 6     lib::set_base_url("http://localhost:8080");
 7     lib::init_settings()?;
 8     loop {
 9         match prompt("Enter your command:").as_str() {
10             "settings" => {
11                 let url = prompt("Base URL:");
12                 lib::set_base_url(&url);
13             }
14             "lend" => {
15                 let lendee_id = prompt("Who lends?");
16                 let book_id = prompt("Which book?");
17                 lib::lend_book(&lendee_id, &book_id)
18                     .await
19                     .inspect_err(|e| println!("Error: {e:?}"))
20                     .ok();
21                 println!("Happy reading");
22             }
23             "return" => {
24                 let book_id = prompt("Which book?");
25                 lib::return_book(&book_id)
26                     .await
27                     .inspect_err(|e| println!("Error: {e:?}"))
28                     .ok();
29                 println!("Returned the book successfully");
30             }
31             "quit" => break Ok(()),
32             unknown => println!("command not found: {unknown}"),
33         }
34     }
35 }
36
37 fn prompt(prompt: &str) -> String {
38     print!("{prompt} ");
39     let mut buf = String::new();
40     std::io::stdout().flush().unwrap();
41     std::io::stdin().read_line(&mut buf).unwrap();
42     buf.trim().to_string()
43 }
 
ДОДАТОК В
Програмний код клієнтської частини
В.1 Код компоненту відображення бібліотеки


 1 import { Link } from "react-router-dom";
 2 import { useLocale } from "../locale";
 3
 4 function Library({ library }) {
 5   const locale = useLocale();
 6
 7   return (
 8     <div key={library.id} className="bg-gray-100 rounded-lg p-4">
 9       <Link to={`/libraries/${library.id}`} className="block">
10         <h2 className="font-semibold text-lg mb-2">{library.name}</h2>
11         <p className="text-gray-600 mb-2">{`${locale.address}: ${library.address}`}</p>
12         <div className="flex justify-between">
13           <p className="text-gray-700">{`${locale.dailyRate}: ${library.dailyRate}`}</p>
14           <p className="text-gray-700">{`${locale.overdueRate}: ${library.overdueRate}`}</p>
15         </div>
16         <p className="text-gray-700">{`${locale.currency}: ${library.currency}`}</p>
17       </Link>
18     </div>
19   );
20 }
21
22 export default Library;

В.2 Код хуку для використання інтернаціоналізації


 1 import { useState, useEffect } from "react";
 2
 3 export function useLocale() {
 4   let [locale, setLocale] = useState({});
 5   const language = localStorage.getItem("language") || "en";
 6   useEffect(() => {
 7     fetch(`/locales/${language}/dictionary.json`)
 8       .then((res) => res.json())
 9       .then((res) => setLocale(res));
10   }, []);
11   return locale;
12 }
 
В.3 Код сторінки для створення резервних копій бази даних


 1 import React, { useState } from "react";
 2 import { useLocale } from "../locale";
 3
 4 function BackupPage() {
 5   const [backup, setBackup] = useState("");
 6   const locale = useLocale();
 7
 8   const handleGet = () => {
 9     fetch("http://localhost:8080/backup", { credentials: "include" })
10       .then((response) => {
11         if (response.ok) {
12           return response.text();
13         }
14         throw new Error("Failed to fetch backup");
15       })
16       .then((data) => setBackup(data))
17       .catch((error) => console.log(error.message));
18   };
19
20   const handleDownload = () => {
21     const element = document.createElement("a");
22     const file = new Blob([backup], { type: 'text/plain' });
23     element.href = URL.createObjectURL(file);
24     element.download = "backup.sql";
25     document.body.appendChild(element);
26     element.click();
27   };
28
29   return (
30     <div className="p-4">
31       <div className="flex mb-10 gap-10 items-center">
32         <h1 className="text-2xl font-bold mb-4">{`${locale.backupTitle}`}</h1>
33         <button
34           className="bg-blue-500 text-white px-4 py-2 rounded"
35           onClick={handleGet}
36         >
37           {`${locale.requestBackup}`}
38         </button>
39         <button
40           className="bg-green-500 text-white px-4 py-2 rounded disabled:opacity-70"
41           onClick={handleDownload}
42           disabled={!backup}
43         >
44       {`${locale.downloadBackup}`}
45         </button>
46       </div>
47       <textarea
48         className="w-full h-96 p-2 border border-gray-300"
49         readOnly
50         value={backup}
51       />
52     </div>
53   );
54 }
55
56 export default BackupPage;
 
ДОДАТОК Г
Результат перевірки записки до курсової роботи на плагіат


 
Рисунок Г.1 – Перша сторінка звіту перевірки на плагіат
